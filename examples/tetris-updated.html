<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple Tetris Game</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: linear-gradient(135deg, #232526 0%, #414345 100%);
        overflow: hidden;
        margin: 0;
        font-family: Arial, sans-serif;
        color: white;
      }

      #scoreContainer {
        text-align: center;
        font-size: 2em;
        margin-bottom: 20px;
        padding: 10px 30px;
        border-radius: 12px;
        background: rgba(20, 20, 50, 0.5);
        backdrop-filter: blur(5px);
        box-shadow: 0 2px 20px 0 #0ff9, 0 2px 10px 0 #f0f, 0 1px 20px 0 #fff4;
        text-shadow: 0 4px 16px #00e6ffb4, 0 2px 8px #ff4ddb70;
        border: 2px solid #65f7ffd0;
        transition: box-shadow 0.4s;
      }

      #scoreContainer:hover {
        box-shadow: 0 1px 40px 0 #0ff, 0 2px 30px 0 #f0f, 0 1px 30px 0 #fff, 0 0 0 #0000;
      }

      canvas {
        background: #101824;
        display: block;
        border-radius: 16px;
        box-shadow: 0 0 70px 8px #2dfdff55, 0 0 3px 1px #fff6, 0 8px 32px #9100ff51;
        transition: box-shadow 0.6s;
        position: relative;
        z-index: 9;
        animation: glow 2.6s infinite alternate;
      }

      @keyframes glow {
        from {
          box-shadow: 0 0 30px 8px #7cfff355, 0 0 3px 1px #fff6, 0 8px 32px #a799ff31;
        }
        to {
          box-shadow: 0 0 90px 14px #23e3ffaa, 0 0 8px 2px #fff, 0 8px 52px #d900ff55;
        }
      }
    </style>
  </head>
  <body>
    <div id="scoreContainer">Score: <span id="score">0</span></div>
    <canvas id="tetris" width="240" height="400"></canvas>
    <script>
      const canvas = document.getElementById("tetris");
      const context = canvas.getContext("2d");
      context.scale(20, 20);

      // FANCY EFFECT: Add shadow and gradient overlay to tetromino tiles
      function drawMatrix(matrix, offset) {
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value !== 0) {
              // Shadow under the tile for depth
              context.save();
              context.shadowColor = "#fff";
              context.shadowBlur = 15;
              context.shadowOffsetX = 0.05;
              context.shadowOffsetY = 0.05;
              // Gradient fill for each block
              let grad = context.createLinearGradient(
                x + offset.x, y + offset.y,
                x + offset.x + 1, y + offset.y + 1
              );
              grad.addColorStop(0, lighten(colors[value], 0.38));
              grad.addColorStop(0.4, colors[value]);
              grad.addColorStop(1, darken(colors[value], 0.22));

              context.fillStyle = grad;
              context.fillRect(x + offset.x, y + offset.y, 1, 1);

              // Draw 'border' for each tile
              context.lineWidth = 0.08;
              context.strokeStyle = "#fff9";
              context.strokeRect(x + offset.x+0.04, y + offset.y+0.04, 0.92, 0.92);

              context.restore();
            }
          });
        });
      }
      // Utils for effects
      function lighten(col, amt) {
        let c = parseInt(col.slice(1), 16);
        let r = ((c >> 16) + 255 * amt) / (1 + amt);
        let g = (((c >> 8) & 255) + 255 * amt) / (1 + amt);
        let b = ((c & 255) + 255 * amt) / (1 + amt);
        return `rgb(${r|0}, ${g|0}, ${b|0})`;
      }
      function darken(col, amt) {
        let c = parseInt(col.slice(1), 16);
        let r = ((c >> 16) * (1-amt));
        let g = (((c >> 8) & 255) * (1-amt));
        let b = ((c & 255) * (1-amt));
        return `rgb(${r|0}, ${g|0}, ${b|0})`;
      }
      // … Unchanged …
      function draw() {
        // Animated background effect
        let t = performance.now() * 0.00032;
        let grad= context.createLinearGradient(0, 0, 12, 20);
        grad.addColorStop(0, `hsl(${(t*120)%360},72%,25%)`);
        grad.addColorStop(1, `hsl(${(t*220+150)%360},86%,17%)`);
        context.fillStyle = grad;
        context.fillRect(0, 0, canvas.width, canvas.height);
        drawMatrix(arena, { x: 0, y: 0 });
        drawMatrix(player.matrix, player.pos);
        updateParticles();
      }
      // … Unchanged …

      const colors = [
        null,
        "#FF0D72",
        "#0DC2FF",
        "#0DFF72",
        "#F538FF",
        "#FF8E0D",
        "#FFE138",
        "#3877FF",
      ];

      // Particle explosion on line clear
      function spawnParticles(y) {
        const num = 24;
        for(let i=0;i<num;i++){
          createParticle(
            (Math.random() * 12),
            y + Math.random()*0.3,
            1.5*Math.cos(i/num*Math.PI*2),
            -2*Math.abs(Math.sin(i/num*Math.PI*2)+Math.random()*0.7),
            colors[1 + (Math.random()*6)|0]
          );
        }
      }
      let particles = [];
      function createParticle(x, y, vx, vy, color) {
        particles.push({x, y, vx, vy, color, life: 50+Math.random()*20});
      }
      // Draw & update particles
      function updateParticles() {
        for (let i=particles.length-1; i>=0; --i){
          let p = particles[i];
          p.x += p.vx*0.09;
          p.y += p.vy*0.09+0.03;
          p.vy += 0.08;
          p.life--;
          context.save();
          context.globalAlpha = Math.max(0, Math.min(1, p.life/50));
          context.beginPath();
          context.arc(p.x, p.y, 0.18, 0, Math.PI*2, 1);
          context.fillStyle = p.color;
          context.shadowColor = p.color;
          context.shadowBlur = 8;
          context.fill();
          context.restore();
          if (p.life<=0) particles.splice(i,1);
        }
      }
      // call in draw()
      function draw() {
        // Animated background effect
        let t = performance.now() * 0.00032;
        let grad = context.createLinearGradient(0, 0, 12, 20);
        grad.addColorStop(0, `hsl(${(t*120)%360},72%,25%)`);
        grad.addColorStop(1, `hsl(${(t*220+150)%360},86%,17%)`);
        context.fillStyle = grad;
        context.fillRect(0, 0, canvas.width, canvas.height);
        drawMatrix(arena, { x: 0, y: 0 });
        drawMatrix(player.matrix, player.pos);
        updateParticles();
      }
      // modify arenaSweep for sparkles
      function arenaSweep() {
        let rowCount = 1;
        outer: for (let y = arena.length - 1; y > 0; --y) {
          for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) {
              continue outer;
            }
          }
          const row = arena.splice(y, 1).fill(0);
          arena.unshift(row);
          ++y;
          // FANCY: spawn sparkles on row clear
          spawnParticles(y);
          player.score += rowCount * 10;
          rowCount *= 2;
        }
      }
      // … Unchanged …
    </script>
  </body>
</html>
